# Vue的响应式原理

Vue是采用**数据劫持**结合**发布者-订阅者模式**，通过**Object.defindProperty(Vue3为Proxy)**对属性的各个**setter**和**getter**进行劫持，vue的组件对应着一个Watcher实例作为订阅者，当数据发生变化时，各个属性作为发布者通知订阅者触发对应回调，更新视图。

- 需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化
- compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
- Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:     
  - ①在自身实例化时往属性订阅器(dep)里面添加自己 
  - ②自身必须有一个update()方法     
  - ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。
- MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化     -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a286bdc076ae425fb9591bb8c4153240~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)



## Object.defineProperty()来进行数据劫持有什么缺点

在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改**数组**数据或者给**对象**新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过**重写函数**的方式解决了这个问题。

在 Vue3.0 中已经不使用这种方式了，而是通过使用 **Proxy** 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。






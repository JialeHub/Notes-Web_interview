# Vue原理

## Vue的响应式原理

Vue是采用**数据劫持**结合**发布者-订阅者模式**，通过**Object.defindProperty(Vue3为Proxy)**对属性的各个**setter**和**getter**进行劫持，vue的组件对应着一个Watcher实例作为订阅者，当数据发生变化时，各个属性作为发布者通知订阅者触发对应回调，更新视图。

- 需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化
- compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
- Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:     
  - ①在自身实例化时往属性订阅器(dep)里面添加自己 
  - ②自身必须有一个update()方法     
  - ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。
- MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化     -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a286bdc076ae425fb9591bb8c4153240~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)



## Object.defineProperty()来进行数据劫持有什么缺点

在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改**数组**数据或者给**对象**新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过**重写函数**的方式解决了这个问题。

在 Vue3.0 中已经不使用这种方式了，而是通过使用 **Proxy** 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。



##  Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？

数据更新了，但**视图并未刷新**，Vue没有将某个对象的值转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局 api **$set()**

```js
this.$set(this.obj, 'b', 'value') //this.obj.b='value'
```



## Vue中封装的数组方法有哪些，其如何实现页面更新

在Vue2中，对响应式处理利用的是**Object.defineProperty**对数据进行拦截，而这个方法并**不能监听到数组内部变化**，数组长度变化，数组的截取变化等，所以需要对这些操作进行hack，让Vue能监听到其中的变化。 

重写的方法：  "push",  "pop",  "shift",  "unshift",  "splice",  "sort",  "reverse"

Vue重写了数组中的那些原生方法，首先获取到这个数组的__ ob __，也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化（也就是通过`target__proto__ == arrayMethods`来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。



## Vue 单页应用(SPA)与多页应用(MPA)的区别

- SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。
- MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。

![775316ebb4c727f7c8771cc2c06e06dd.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76b3d747986e45e096abaf64faf5e332~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)



## Vue template 到 render 的过程

vue的模版编译过程主要如下：**template -> ast -> render函数**

vue 在模版编译版本的码中会执行 **compileToFunctions** 将template转化为render函数。
CompileToFunctions中的主要逻辑如下∶

1. 调用parse方法将template转化为ast（抽象语法树）

   ```js
   constast = parse(template.trim(), options)
   //parse的目标：把tamplate转换为AST树，它是一种用 JavaScript对象的形式来描述整个模板。
   //解析过程：利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的 回调函数，来达到构造AST树的目的。
   //AST元素节点总共三种类型：type为 1表示普通元素、2为表达式、3为纯文本
   ```

2. 对静态节点做优化

   ```js
   optimize(ast,options)
   //这个过程主要分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化
   //深度遍历AST，查看每个子树的节点元素是否为静态节点或者静态节点根。如果为静态节点，他们生成的DOM永远不会改变，这对运行时模板更新起到了极大的优化作用。
   ```

3. 生成代码

   ```js
   const code = generate(ast, options)
   //generate将ast抽象语法树编译成 render字符串并将静态部分放到 staticRenderFns 中，最后通过 new Function(`` render``) 生成render函数。
   ```



## Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？

**不会**立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是**异步执行**的。只要侦听到数据变化， Vue 将开启一个队列，并**缓冲在同一事件循环中发生的所有数据变更**。

如果**同一个watcher被多次触发，只会被推入到队列中一次**。这种在缓冲时**去除重复数据**对于**避免不必要的计算和 DOM 操作**是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。






# 操作系统

## 32位系统和64位体统的区别

32位和64位表示CPU一次能处理的最大位数，理论上来说，64位系统处理的数据效率比32位更高

32位CPU和操作系统最大只可支持4G内存，64位多达128 GB

64位兼容32位，反过来不行



## 线程和进程

**进程（Process）** 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的 基本单位，是操作系统结构的基础。 在当代面向线程设计的计算机结构中，进程是线程的容器。程序是 指令、数据及其组织形式的描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行 活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形 式的描述，进程是程序的实体。 

**线程（thread）** 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运 作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行 执行不同的任务。 

**总结**：
**进程**：指在系统中正在运行的一个**应用程序**；程序一旦运行就是进程；进程：**资源分配的最小单位**。 
**线程**：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程：**程序执行的最小单位**。

**区别**：
**独立性**：**进程**可以看做**独立应用**，**线程不能**
**资源**：进程是**cpu资源分配的最小单位**（是能拥有资源和独立运行的最小单位）；线程是**cpu调度的最小单位**（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。
**通信方面**：**线程**间可以通过直接**共享**同一进程中的资源，而**进程**通信需要借助**进程间通信**。
**调度**：**进程切换**比线程切换的**开销大**。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
**系统开销**：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I/O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。

**特点**：

1. **进程中的任意一线程执行出错，都会导致整个进程的崩溃**
2. **线程之间共享进程中的数据**
3. **当一个进程关闭之后，操作系统会回收进程所占用的内存**
4. **进程之间的内容相互隔离**



## 进程间通信

每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间 要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从 内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。

- **管道**：管道就是操作系统在内核中开辟的一段**缓冲区**，进程1可将要交互的数据拷到缓冲区，进程2就可读取了，特点：

  - **半双工**的通信方式，数据只能**单向流动**
  - 而且只能在具有**亲缘关系**（通常是指父子进程关系）的进程间使用。
  - 依赖于**文件系统**
  - **生命周期**随进程
  - 面向**字节流**的服务
  - 管道内部提供了**同步机制**

- **有名管道/命名管道**：有名管道也是**半双工**的通信方式，但是它允许**无亲缘关系**进程间的通信。

- **信号**：是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），用于**通知接收进程某个事件已经发生**，它也是用户进程之间通信和同步的一种原始机制。

- **信号量**：信号量是一个**计数器**，实现进程之间的**互斥与同步**，可以用来控制多个进程对共享资源的访问。它常作为一种**锁机制**，防止某进程正在访问共享资源时，其他进程也访问该资源（多进程竞争内存的问题、类似线程安全问题）。

- **消息队列**：消息队列是由**消息的链表**存放在内核中并由**消息队列标识符**标识，用户可以在消息队列中添加消息、读取消息等。消息队列提供了一种从一个进程向另一个进程发送一个**数据块**的方法。 每个数据块都被认为含有一个**类型**，接收进程可以独立地接收含有不同类型的数据结构。

  **优点**：消息队列**克服**了信号**传递信息少**、 管道只能承载**无格式字节流**以及**缓冲区大小受限**等缺点，避免命名管道的**同步和阻塞问题**。**缺点**：但是消息队列与命名管道一样，**每个数据块都有一个最大长度的限制**。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间。

- **共享内存**：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问（使多个进程可以访问同一块内存空间）。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。

- **套接字通信**：上面说的都是多个进程在**一台**主机之间的通信，若想**两主机之间远程通信**，Socket 就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。



## 线程间的通信方式
- 使用全局变量
- 使用消息实现通信
- 使用事件CEvent类实现线程间通信



## 僵尸进程和孤儿进程是什么

**孤儿进程**：**父进程退出**了，而它的一个或多个**子进程还在运行**，那这些子进程都会成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

**僵尸进程**：**子进程比父进程先结束**，而**父进程又没有释放子进程占用的资源**，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。



## 死锁产生的原因？ 如果解决死锁的问题？

死锁是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。

### 死锁的原因：

- **竞争资源**：产生死锁中的竞争资源：
  - **竞争不可剥夺资源**（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）；
  - **竞争临时资源**（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁
- **进程间推进顺序非法**：若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁



### 如何避免死锁：破坏四条件之一

- **互斥条件**：一个资源每次只能被一个线程使用
- **请求与保持条件**：一个线程因请求资源而阻塞时，对已获得的资源保持不放，**避免方法**：
  1. 资源**一次性分配**：一次性分配所有资源，这样就不会再有请求了
  2. 只要有一个资源**得不到分配**，也**不给这个进程分配其他的资源**
- **不剥夺条件**：系统中的资源可以分为两类：**可剥夺**资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；**不可剥夺**资源，线程已获得的资源，在未使用完之前不能强行剥夺，只能在进程用完后自行释放，如磁带机、打印机等。**避免方法**：
  - 即当某进程获得了部分资源，但**得不到其它资源**，则**释放已占有的资源**（不可剥夺转为可剥夺）

- **循环/环路等待条件**：若干线程之间形成一种头尾相接的**环形链**循环等待资源关系，**避免方法**：
  - 系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反




## 进程调度策略

- 先来先服务
- 短作业(进程)优先
- 高优先权优先
- 高响应比优先
- 时间片轮转法
- 多级反馈队列



## 并发与并行的区别

- 并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的**切换**完成了这两个任务，这种情况就可以称之为并发。
- 并行是微观概念，假设 CPU 中存在两个核心，那么我就可以**同时完成**任务 A、B。同时完成多个任务的情况就可以称之为并行。



# 浏览器从输入网址到页面展现的整个过程

## 1.URL 解析

	检查URL是否合法，把URL解析成协议、网站地址、端口、文件路径、querry参数和值、hash锚点，提取网站地址(域名进行下一步访问)

## 2.缓存判断

```
浏览器请求前先查看浏览器是否缓存了该资源，如果有缓存查看缓存是否过期，对比cache-control(Http1.1，相对时间、缓存范围) 或者Expires(Http1.0,绝对时间)：
- 1.强缓存：如果没过期直接返回资源，并返回200
- 2.协商缓存：如果过期了就开始访问服务器（第二步结束）
		- 1.如果缓存有ETag(Http1.1)，请求头带上If-None-Match，服务器对比资源文件特征码是否一致
		- 2.如果缓存没有ETag，有Last-Modified，请求头带上If-Modified-Since，服务器对比资源修改时间是否一致
		- 如果资源没过期则返回304，取缓存、否则重新返回新资源返回200
```

## 3.DNS 查询

	找到域名对应的IP，先查找是否有DNS缓存：浏览器缓存 → 系统缓存(hosts文件记录) → 路由器缓存。如果没有记录则查询DNS服务器。最终获取到相应IP地址
	客户端 ⇋ 本地DNS服务器默认递归查询，本地DNS服务器 ⇋ 其他域名服务器默认迭代查询：
												 ⇋ 1.根域名服务器
		客户端 ⇋ 本地DNS服务器  ⇋ 2.顶级域名服务器
	                    		 ⇋ 3.权威域名服务器

## 4.获取MAC地址

```
应用层        HTTP
  ↓			      ↓	
传输层      TCP(端口号)
  ↓			      ↓	
网络层     	IP地址
  ↓			      ↓	
数据链路层   MAC地址      通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，
  ↓			      ↓	        可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它
物理层      网线/WIFI     代为转发，此时同样可以通过ARP协议来获取网关的MAC地址，此时目的主机的MAC地址应该为网关的地址。
```

## 4.TCP连接 三次握手

```
根据IP、端口号进行TCP封包，数据包经过 传输层 → 网络层 → 数据链路层 → 物理层 传输给目标服务器，经过三次握手进行连接：

TCP三次握手：
1.首先客户端向服务器发送一个 SYN 连接请求报文段、随机序号seq，客户端进入SYN_SENT状态，等待服务器端确认。
2.服务端接收到请求后向服务器端发送一个 SYN ACK报文段、确认号ack、随机序号seq，服务器端进入SYN_RCVD状态。
3.客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段、确认号ack、随机序号seq，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了，客户端和服务器端进入ESTABLISHED状态。

如果使用的是 HTTPS 协议，还要进行HTTPS四次握手(略)
```

![img](https://img-blog.csdnimg.cn/2021032320474182.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjQ3ODA5,size_16,color_FFFFFF,t_70)

## 5.发送HTTP请求

	TCP建立连接后，浏览器发送HTTP请求给服务器(包括请求方法、请求头、请求体)

## 6.服务器处理请求并返回HTTP报文

	服务器解析处理请求，返回相应资源

## 7.浏览器解析渲染页面

	浏览器拿到HTML、CSS文件后进行解析，浏览器开始构建DOM树、CSSOM树，当HTML解析到script标签时，则判端是否含有 defer 或者 async 属性，否则会暂停解析HTML和CSS造成阻塞，等JS请求返回资源后，浏览器解析脚本，然后继续解析HTML和CSS（所以推荐脚本放到HTML文件后面），遇到外部媒体资源会并行下载，然后合成为渲染树，浏览器通过渲染树进行布局、绘制、合成渲染、GPU栅格化最终显示到用户的显示器上。

## 8.连接结束 四次挥手

	四次挥手断开TCP连接：
	1.客户端发起挥手请求，向服务端发送FIN报文段，设置序列号seq，此时，客户端进入FIN_WAIT_1状态，这表示客户端没有数据要发送给服务端了。
	2.服务端收到了客户端报文，向客户端返回一个标志位是ACK的报文段、确认号ack、随机序号seq，客户端进入FIN_WAIT_2状态，服务端告诉客户端，我确认并同意你的关闭请求。
	3.服务端向客户端发送 FIN ACK 的报文段、确认号ack、随机序号seq，请求关闭连接，同时客户端进入LAST_ACK状态。
	4.客户端收到服务端发送的报文，向服务端发送标志位是ACK的报文段、确认号ack、随机序号seq，然后客户端进入TIME_WAIT状态。服务端收到客户端的ACK报文段以后，就关闭连接。此时，客户端等待2MSL的时间后(保证TCP协议的全双工连接能够可靠关闭、保证这次连接的重复数据段从网络中消失)依然没有收到回复，则证明服务端已正常关闭，客户端也可以关闭连接了。

![img](https://img-blog.csdnimg.cn/20210323204828555.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjQ3ODA5,size_16,color_FFFFFF,t_70)

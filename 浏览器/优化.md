# 浏览器优化



## 渲染优化

### 针对JavaScript

JavaScript既会阻塞HTML的解析，也会阻塞CSS的解析。HTML 遇到 普通的script 会立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；因此我们可以对JavaScript的**加载方式**进行改变，来进行优化：

- 尽量将JavaScript文件放在body的最后

- body中间尽量不要写`<script>`标签

- script 标签引入资源方式有三种：
  1. **默认script** 同步，会堵塞文档加载，直到下载加载完。
  
  2. **async** html5.0，优先级更高，一边下载一边加载文档，下载后暂停解析文档加载它
  
  3. **defer** html4.0，延迟加载，边下载边加载，等文档加载完再加载它
  
     async和defer都是异步，加载时不堵塞页面渲染，当script中间有代码都不起作用、脚本不能调用document.write方法、有onload事件回调：
  
     

### 针对CSS

使用CSS的方式：

- **link**：浏览器会派发一个新等线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码
- **@import**：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)
- **style**：GUI直接渲染

外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以CSS一般写在headr中，让浏览器尽快发送请求去获取css样式。所以，在开发过程中，**导入外部样式使用link，而不用@import**。如果**css少**，尽可能采用内嵌样式，直接写在**style标签**中。



### 针对DOM树、CSSOM树

- **HTML**文件的代码**层级**尽量不要太深
- 使用**语义化**的标签，来避免不标准语义化的特殊处理
- 减少**CSS**代码的**层级**，因为选择器是**从右往左进行解析**的



### 减少回流与重绘

- 详情参考后文



## 懒加载

懒加载也叫做**延迟加载**、**按需加载**，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。在比较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口的那一部分图片数据，这样就浪费了性能。如果使用图片的懒加载就可以解决以上问题。在滚动屏幕之前，**可视化区域之外的图片不会进行加载，在滚动屏幕时才加载**。这样使得网页的加载速度更快，减少了服务器的负载。懒加载适用于图片较多，页面列表较长（长列表）的场景中。

**特点**：

- **减少无用资源的加载**：使用懒加载明显减少了服务器的压力和流量，同时也减小了浏览器的负担。
- **提升用户体验**: 如果同时加载较多图片，可能需要等待的时间较长，这样影响了用户体验，而使用懒加载就能大大的提高用户体验，可以提高网站的首屏加载速度。
- **防止加载过多图片而影响其他资源文件的加载** ：会影响网站应用的正常使用。

**实现原理**：

图片的加载是由`src`引起的，当对`src`赋值时，浏览器就会请求图片资源。根据这个原理，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性（data-xxx）中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性（data-xxx）中取出真实路径（src路径）赋值给图片的 src 属性，以此来实现图片的延迟加载。注意：我们使用HTML5 的`data-xxx`属性来储存图片的路径，`data-xxx` 中的`xxx`可以自定义，这里我们使用`data-src`来定义。

```html
//window.innerHeight 是浏览器可视区的高度
//document.body.scrollTop || document.documentElement.scrollTop 是浏览器滚动的过的距离
//imgs.offsetTop 是元素顶部距离文档顶部的高度（包括滚动条的距离）
//图片加载条件：img.offsetTop < window.innerHeight + document.body.scrollTop;
<div class="container">
     <img src="loading.gif"  data-src="pic.png">
     <img src="loading.gif"  data-src="pic.png">
</div>
<script>
var imgs = document.querySelectorAll('img');
function lozyLoad(){
		var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
		var winHeight= window.innerHeight;
		for(var i=0;i < imgs.length;i++){
			if(imgs[i].offsetTop < scrollTop + winHeight ){
				imgs[i].src = imgs[i].getAttribute('data-src');
			}
		}
	}
  window.onscroll = lozyLoad();
</script>
```



## 预加载和懒加载的区别

懒加载和预加载都是提高网页性能的方式，**预加载**是**提前加载**，**懒加载**是**迟缓甚至不加载**。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。

**懒加载**：也叫**延迟加载**，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。

**预加载**：指的是将**所需的资源提前请求加载到本地**，这样后面在需要用到时就**直接从缓存取资源**。 通过预加载能够**减少用户的等待时间**，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。



## 回流与重绘

当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。

### 回流

当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为**回流**。

下面这些操作会导致回流：

- 页面的**首次渲染**
- 浏览器的**窗口大小**发生变化 resize
- 元素的**内容**发生变化
- 元素的**尺寸**或者**位置**发生变化
- 元素的**字体大小**发生变化
- 激活CSS**伪类**
- **添加或者删除**可见的**DOM元素**
- 查询某些属性或者调用某些方法

在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的DOM元素重新排列，它的影响范围有两种：

- 全局范围：从根节点开始，对整个渲染树进行重新布局
- 局部范围：对渲染树的某部分或者一个渲染对象进行重新布局



### 重绘

当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是**重绘**。

下面这些操作会导致回流：

- color、background 相关属性：background-color、background-image 等
- outline 相关属性：outline-color、outline-width 、text-decoration
- border-radius、visibility、box-shadow



### 如何避免回流与重绘？

- 操作DOM时，尽量在**低层级的DOM节点进行操作**
- **不要使用`table`布局**， 一个小的改动可能会使整个`table`进行重新布局
- 使用CSS的表达式
- 不要频繁操作元素的样式，对于静态页面，可以**修改类名，而不是样式**。
- 使用absolute或者fixed，使元素**脱离文档流**，这样他们发生变化就不会影响其他元素
- 避免频繁操作DOM，可以创建一个**文档片段`documentFragment`**，在它上面应用所有DOM操作，最后再把它添加到文档中
- 将元素**先设置`display: none`，操作结束后再把它显示出来**。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
- 将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于**浏览器的渲染队列机制**：浏览器针对页面的回流与重绘，进行了自身的优化——**渲染队列**：**浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。**将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。



## 如何优化动画？

对于如何优化动画，我们知道，一般情况下，动画需要频繁的操作DOM，就就会导致页面的性能问题，我们可以将动画的`position`属性设置为`absolute`或者`fixed`，将动画**脱离文档流**，这样他的回流就不会影响到页面了。



## documentFragment 文档片段

DocumentFragment，文档片段接口，一个没有父对象的最小文档对象。它被作为一个轻量版的 Document使用，就像标准的document一样，存储由节点（nodes）组成的文档结构。与document相比，最大的区别是DocumentFragment不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会导致性能等问题。

当我们把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。在频繁的DOM操作时，我们就可以将DOM元素插入DocumentFragment，之后一次性的将所有的子孙节点插入文档中。和直接操作DOM相比，将DocumentFragment 节点插入DOM树时，不会触发页面的重绘，这样就大大提高了页面的性能。



## 防抖节流

**函数防抖**：指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。常用**场景**如下：

- 按钮提交场景：防⽌多次提交按钮，只执⾏最后提交的⼀次
- 服务端验证场景：表单验证需要服务端配合，只执⾏⼀段连续的输⼊事件的最后⼀次，还有**搜索联想词**功能类似⽣存环境请⽤lodash.debounce

```js
function throttle(func,wait){
  let timeout//lock
  return function(){
    if(!timeout){
      timeout=setTimeout(()=>{
        timeout=null
        func.apply(this,arguments)
      },wait)
    }
  }
}
```

**函数节流**：指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。常用**场景**如下：

- **拖拽**：固定时间内只执⾏⼀次，防⽌超⾼频次触发位置变动
- **缩放**：监控浏览器resize
- **动画**：避免短时间内多次触发动画引起性能问题

```js
function debounce2(func,time,immediate){
  let timeout
  return function(){
    let res
    if(immediate){
      let callNow = !timeout //timeout == Lock
      timeout = setTimeout(()=>{
        timeout = null
      },time)
      if(callNow) res=func.apply(this,arguments)
    }else{
      if(timeout) clearTimeout(timeout)
      timeout = setTimeout(()=>{
        func.apply(this,arguments)
      },time)
    }
    return res
  }
}
```



## 图片优化

1. 合理利用**懒加载** / **预加载**

1. **不用图片**。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。

2. 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出**适配屏幕的宽度**，然后去请求相应裁剪好的图片。

3. 小图使用 **base64** 格式

4. 将多个图标文件整合到一张图片中（**雪碧、精灵图**）

5. 选择正确的图片格式：

   - 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好
   - 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替
   - 照片使用 JPEG

   |           | 类型   | 压缩      | 颜色          | 透明度 | 大小 | 用途特点           |
   | --------- | ------ | --------- | ------------- | ------ | ---- | ------------------ |
   | BMP       | 点阵图 | 无        | 索引色/直接色 | 不支持 | 大   | 原图               |
   | GIF       | 点阵图 | 无损      | 8bit索引色    | 支持   | 较小 | 透明动画           |
   | **PNG-8** | 点阵图 | 无损      | 索引色        | 支持   | 更小 | **低质量透明图**   |
   | PNG-24    | 点阵图 | 无损      | 直接色        | 支持   | 较大 | 高质量透明图       |
   | **JPEG**  | 点阵图 | 有损      | 直接色        | 不支持 | 中   | 存储**照片**、大图 |
   | **WebP**  | 点阵图 | 无损/有损 |               | 支持   | 很小 | 网页最佳           |
   | **SVG**   | 矢量图 | 无损      | 直接色        | 支持   | 很小 | logo、图标         |
   
     


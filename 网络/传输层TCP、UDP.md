# TCP和UDP区别

TCP 和 UDP都是传输层协议，他们都属于TCP/IP协议族：

|              | TCP                                    | UDP                                |
| ------------ | -------------------------------------- | ---------------------------------- |
| 传输方式     | 面向字节流                             | 面向报文                           |
| 可靠         | 可靠传输，保证都交付                   | 不可靠，尽最大能力交付             |
| 连接对象个数 | 一对一通信                             | 一对一，一对多，多对一和多对多     |
| 是否连接     | 面向连接                               | 无连接                             |
| 首部开销     | 最小20字节，最大60字节                 | 8字节                              |
| 适用场景     | 适用于要求可靠传输的应用，例如文件传输 | 适用于实时应用，例如视频会议、直播 |



## UDP

UDP的全称是**用户数据报协议**，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。以下是它的特点：

- **面向无连接**

  - 首先 UDP 是不需要和 TCP 一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。
  - 在**发送端**，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据**增加 UDP 头标识**下是 UDP 协议，然后就传递给网络层了
  - 在**接收端**，网络层将数据传递给传输层，UDP 只**去除 IP 报文头**就传递给应用层，不会任何拼接操作

- **有单播，多播，广播的功能**

- **面向报文**

  UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文

- **不可靠性，尽最大能力交付**

  - 不保证消息**交付**：不确认，不重传，无超时
  - 不保证交付**顺序**：不设置包序号，不重排，不会发生队首阻塞
  - 不跟踪连接**状态**：不必建立连接或重启状态机
  - 不进行**拥塞控制**：不内置客户端或网络反馈机制

- **头部开销小(8字节)，传输数据报文时是很高效的**

  ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14d246d14aac47919989fc620fbb17dd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

  UDP 头部包含了以下几个数据：

  - 两个十六位(2字节)的端口号，分别为**源端口**（可选字段）和**目标端口**
  - 整个数据报文的**长度**
  - 整个数据报文的**检验和**（IPv4 可选字段），该字段用于发现头部信息和数据中的错误

  因此 UDP 的头部开销小，只有8字节，相比 TCP 的至少20字节要少得多，在传输数据报文时是很高效的。



## TCP

TCP的全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 是面向连接的、可靠的流协议（流就是指不间断的数据结构），它有以下几个特点：

- **面向连接**

  面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。

- **仅支持单播传输**

  每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。

- **面向字节流**

  TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。

- **可靠传输，保证都交付**（TCP如何保证可靠性）

  - **seq序列号、ack确认号**：对于可靠传输，判断丢包、误码靠的是TCP的段编号(seq)以及确认号(ack)。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ack)；

  - **超时重传机制**：由于TCP的下层网络可能出现**丢失、重复或失序**的情况，TCP协议提供可靠数据传输服务。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。TCP使用两套独立的机制来完成重传，一是**基于时间**，二是基于**确认信息**(ack)。TCP在发送一个数据之后，就开启一个定时器，如果发送端实体在合理的往返时延(**RTT**)内未收到ack确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个**复位**信号。

  - **头部校验和**：由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括**数据部分**。

  - **拥塞控制机制**：当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。

    1. **慢启动（慢开始）**

       开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。在开始发送的时候设置cwnd = 1（cwnd指的是**拥塞窗口**）

       为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限(ssthresh **状态变量**)

       - 当cnwd < ssthresh，使用**慢开始算法**
       - 当cnwd = ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法
       - 当cnwd > ssthresh，使用**拥塞避免算法**

    2. **拥塞避免**

       拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段**将拥塞窗口cwnd控制为按线性增长**，使网络不容易出现阻塞。

       让**拥塞窗口cwnd缓慢的增大**，即每经过一个返回时间**RTT**就把发送方的拥塞控制窗口**+1**

       无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络**出现拥塞**(判断依据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理)，就把**慢开始门限ssthresh**设置为出现拥塞时的发送窗口大小的**一半**。然后把**拥塞窗口cnwd**设置为**1**，执行**慢开始**算法。

       ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06b60b174bb242b498d244002caded1c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

    3. **快速重传**

       快重传要求接收方在收到一个**失序**的报文段后就立即发出**重复确认**(为的是使发送方及早知道有报文段没有到达对方)。发送方只要连续收到**三个重复确认**就**立即重传**对方尚未收到的报文段，而**不必继续等待设置的重传计时器**时间到期。由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量

    4. **快速恢复**

       当发送方**连续收到三个重复确认**时，就执行“**乘法减小**”算法，把**ssthresh门限减半**，但是接下去并**不执行慢开始**算法。考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。

       ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0f5339da8c741d19f416cac2af18e4f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

  - **流量控制机制**

    一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。TCP采用大小可变的**滑动窗口**进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。

    - 当一个连接建立时，连接的每一端分配一个**缓冲区**来保存输入的数据，并将缓冲区的大小发送给另一端。

    - 当数据到达时，接收方发送确认，其中包含了发送方剩余的缓冲区大小。（**剩余的缓冲区空间的大小**被称为**窗口**，指出窗口大小的通知称为**窗口通告** 。接收方在发送的每一确认中都含有一个窗口通告。）

    - 如果接收方应用程序**读数据**的速度能够与**数据到达**的速度**一样快**，接收方将在每一确认中发送一个**正的窗口通告**。

    - 如果**发送**方操作的速度比**接收**方**快**，接收到的数据最终将**充满接收方的缓冲区**，导致接收方通告一个**零窗口** 。发送方收到一个零窗口通告时，必须**停止发送**，直到接收方**重新通告一个正的窗口**。

    

  - **连接管理**：三次握手四次挥手

    - **三次握手**：

      1. 客户端给服务端发一个 SYN 报文：首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，指明客户端的初始化序列号 ISN（seq=x），此时客户端处于 SYN_SEND 状态
      2. 服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答：首部的同步位SYN=1，ACK=1，初始序号seq=y，ack=x+1，指定了自己的初始化序列号 ISN(seq=y)，设置确认号ack=x+1表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。
      3. 客户端收到 SYN 报文之后，会发送一个 ACK 报文：ACK=1，序号seq=x+1，ack=y+1，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。ACK报文段可以携带数据，不携带数据则不消耗序号。

      ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55a81db348584e57abdd01c9555f1d5f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

      - **为什么要三次握手呢？两次不行吗？**
        - 为了确认双方的接收能力和发送能力都正常
        - 如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时**客户端忽略服务端发来的确认**，也**不发送数据**，则**服务端一直等待客户端发送数据**，浪费资源。
    
    - **四次挥手**：
    
      	1. 客户端会发送一个 FIN 报文：FIN=1，序号seq=u。此时客户端处于 FIN_WAIT1 状态，并停止再发送数据，主动关闭TCP连接。
      	1. 服务端收到 FIN 之后，会发送 ACK 报文：ACK=1，确认号ack=u+1，序号seq=v。服务端进入CLOSE_WAIT（关闭等待）状态，TCP处于半关闭状态，客户端到服务端的连接释放。
      	1. 如果服务端也想断开连接了，发给 FIN 报文：FIN=1，ACK=1，序号seq=w，确认号ack=u+1。此时服务端处于LAST_ACK 的状态。
      	1. 客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答：ACK=1，seq=u+1，ack=w+1。客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器端不能正常关闭，需要经过时间等待计时器设置的时间**2MSL**（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃）后，客户端才进入CLOSED状态。
    
      ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4190d0d324b427cb63154d3f84e47bc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)
    
      - **为什么需要四次挥手呢**
    
        因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。
    
        

- **提供全双工通信**

  TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）

- **头部开销较大，最小20字节，最大60字节**

  ![img](https://img-blog.csdnimg.cn/20210130112722747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d3d19kb25n,size_16,color_FFFFFF,t_70)



## TCP和UDP的使用场景

- **TCP应用场景：** **效率要求相对低，但对准确性要求相对高的场景**。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。
- **UDP应用场景：** **效率要求相对高，对准确性要求相对低的场景**。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。



## TCP粘包问题

默认情况下, TCP 连接会启⽤延迟传送算法 (Nagle 算法), 在数据发送之前缓存他们. 如果短时间有多个数据发送, 会缓冲到⼀起作⼀次发送 (缓冲⼤⼩⻅ socket.bufferSize ), 这样可以减少 IO 消耗提⾼性能（比如远程Shell命令的交互）如果是传输⽂件的话, 那么根本不⽤处理粘包的问题, 来⼀个包拼⼀个包就好了。但是如果是多条消息, 或者是别的⽤途的数据那么就需要处理粘包。

连续传输数据的例子：
不粘包：A包(All) + B包(All)
粘包：`A(前面部分) `+ `A(后面部分)&B包(All)` 、 `A(All)&B包(前面部分)` +  `B包(后面部分)` 、 `A(All)&B(All)`

**解决方案**：

- **多次发送之前间隔⼀个等待时间**：只需要等上⼀段时间再进⾏下⼀次 send 就好, 适⽤于交互频率特别低的场景. 缺点也很明显, 对于⽐较频繁的场景⽽⾔传输效率实在太低，不过⼏乎不⽤做什么处理.
- **关闭 Nagle 算法**：在 Node.js 中你可以通过 socket.setNoDelay() ⽅法来关闭 Nagle 算法, 让每⼀次 send 都不缓冲直接发送。该⽅法⽐较适⽤于每次发送的数据都⽐较⼤ (但不是⽂件那么⼤), 并且频率不是特别⾼的场景。如果是每次发送的数据量⽐较⼩, 并且频率特别⾼的, 关闭 Nagle 纯属⾃废武功。另外, 该⽅法不适⽤于⽹络较差的情况, 因为 Nagle 算法是在服务端进⾏的包合并情况, 但是如果短时间内客户端的⽹络情况不好, 或者应⽤层由于某些原因不能及时将 TCP 的数据 recv, 就会造成多个包在客户端缓冲从⽽粘包的情况。 (如果是在稳定的机房内部通信那么这个概率是⽐较⼩可以选择忽略的)
- **进⾏封包/拆包**：封包/拆包是⽬前业内常⻅的解决⽅案了。即给每个数据包在发送之前, 于其前/后放⼀些有特征的数据, 然后收到数据的时 候根据特征数据分割出来各个数据包。

**为什么udp不会粘包**：

- TCP协议是**⾯向流**的协议，UDP是**⾯向消息**的协议。UDP段都是⼀条消息，应⽤程序必须**以消息为单位提取数据**，不能⼀次提取任意字节的数据

- UDP具有**保护消息边界**，在每个UDP包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易进⾏区分处理了。传输协议把数据当作⼀条独立的消息在⽹上传输，接收端只能接收独立的消息。接收端⼀次只能接收发送端发出的⼀个数据包,如果⼀次接受数据的⼤⼩⼩于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收。

  

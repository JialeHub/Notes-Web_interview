# HTTPS

超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由**HTTP**进行通信，利用**SSL/TLS**来加密数据包。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

HTTP协议采用**明文传输**信息，存在**信息窃听**、**信息篡改**和**信息劫持**的风险，而协议TLS/SSL具有**身份验证**、**信息加密**和**完整性校验**的功能，可以避免此类问题发生。安全层的主要职责就是**对发起的HTTP请求的数据进行加密操作** 和 **对接收到的HTTP的内容进行解密操作**。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10885a9d4d574d7caf3fee1416f623ca~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

### 优点

- 使用HTTPS协议可以进行身份认证，**认证用户和服务器**，确保数据发送到正确的客户端和服务器；
- 使用HTTPS协议可以进行**加密传输**，通信更加安全，防止数据在传输过程中被**窃取**、**篡改**、**劫持**，确保数据安全性；
- HTTPS是现行架构下最安全的解决方案，虽然不是绝对的安全，但是**大幅增加了中间人攻击的成本**；
- HTTPS**搜索引擎**排名会提高；

### 缺点

- HTTPS需要做服务器和客户端双方的加密和解密处理，耗费更多**服务器资源**，支持访客稍多的网站需要投入更大的**成本**，过程**复杂**；
- HTTPS协议**握手**阶段比较费时，增加页面的加载时间，要更**耗时**更**耗电**；
- SSL证书是**收费**的，功能越强大的证书费用越高；
- HTTPS的证书只能**域名和IP一一对应**，SSL证书需要绑定IP，不能再同一个IP上绑定多个域名。
- HTTPS**缓存**不如HTTP高效

  





## HTTP和HTTPS区别

HTTP：超文本传输协议

HTTPS：HTTP协议上加入SSL/TLS层进行加密

相同点：都是在应用层的协议，HTTPS的SSL加密是在传输层实现

区别：

- 1.默认**端口**不同：HTTPS：443端口；HTTP：80端口
- 2.HTTPS更加**安全**：以**密文**方式传输，而HTTP是以**明文**方式传输；HTTPS提供**数据加密**、**身份认证**等功能，防止数据被**窃取**、**篡改**、**劫持**，**大幅增加中间人攻击成本**；（优点）
- 3.HTTPS**搜索引擎**排名会提高（优点）
- 4.HTTPS**消耗资源**比HTTP要高、要更**耗时**更**耗电**（缺点）
- 5.HTTPS需要CA证书，要一定的**费用**成本（缺点）
- 6.HTTPS的证书只能**域名和IP一一对应**（缺点）
- 7.HTTPS**缓存**不如HTTP高效（缺点）



##HTTPS建立连接过程

<https://www.cnblogs.com/liziof/p/12001711.html>

客户端对服务器发起https请求，TCP先进行三次握手：SYN、ACK | SYN、ACK，然后是SSL的四次握手：

1. 客户端：商量可接受的加密压缩协议的**等级版本**、**客户随机数**发给S端，

2. 服务端：把加密压缩协议的**等级版本**、**签名、证书、公钥**、**服务随机数**发给C端，

3. 客户端：用CA公钥**校验证书**有效性：

   [ 消息摘要Hash值 = ( 待检验证书 * HASH算法  ) ] ?== [ 消息摘要Hash值 = (  CA公钥(解密) * 待验证数字签名 ) ]，

   认证成功后，生成**pre_master key(预主密钥)**并用服务器公钥加密，并提供一个前面所有内容的 **hash 值**供服务器端**检验握手协商结果**，发给服务器。

4. 服务器：用服务器私钥解开得到pre_master key，同时向客户端发送一个前面所有内容的 **hash 值**供客户端**检验握手协商结果**

之后双方检验握手协商结果成功，计算出对称密钥（客户随机数  *  服务随机数  *  pre_master key）之后一直采用对称密钥加密传输内容...



## SSL 连接断开后如何恢复？

**Session ID**

每一次的会话都有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器如果有这个编号的记录，那么双方就可以继续使用以前的密钥，而不用重新生成一把。

**Session Ticket**

session ticket 是服务器在上一次对话中发送给客户的，这个 ticket 是加密的，只有服务器可能够解密，里面包含了本次会话的信息，比如对话密钥和加密方法等。这样不管我们的请求是否转移到其他的服务器上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了。



## TLS/SSL的工作原理

**TLS/SSL**全称**安全传输层协议**（Transport Layer Security）, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。

TLS/SSL的功能实现主要依赖三类基本算法：**散列函数hash**、**对称加密**、**非对称加密**。这三类算法的作用如下：

- 基于散列函数验证信息的完整性
- 对称加密算法采用协商的秘钥对数据加密
- 非对称加密实现身份认证和秘钥协商

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5696ee8ccb0d44b08b812a7c964695b7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

### 散列函数hash

常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性。

**特点：** 在信息传输过程中，散列函数不能三都实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。

### 对称加密

对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。

常见的对称加密算法有AES-CBC、DES、3DES、AES-GCM等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一。

**特点：** 对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码。

### 非对称加密

非对称加密的方法是，我们拥有一**密钥对(私钥 + 公钥)**。**公钥是公开**的，**私钥是保密**的。用**私钥加密**的数据，只能由对应的**公钥解密**，用**公钥加密**的数据，只能由对应的**私钥解密**。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。

常见的非对称加密算法有RSA、ECC、DH等。秘钥成对出现，一般称为公钥（公开）和私钥（保密）。公钥加密的信息只有私钥可以解开，私钥加密的信息只能公钥解开，因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。

**特点：** 非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。

### **TLS/SSL的工作方式**

客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题。



## 数字证书是什么？

现在的方法也不一定是安全的，因为没有办法确定得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。为了解决这样的问题，可以使用数字证书。

首先使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。

这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90da1f506e7040aaba5e1536c1f6c373~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)



## **HTTPS**是如何保证安全的

对称加密虽然很简单性能也好，但是⽆法解决⾸次把秘钥发给对⽅的问题，很容易被⿊客拦截秘钥；⾮对称加密虽然安全性更⾼，但是带来的问题就是速度很慢，影响性能。结合两种加密⽅式，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去，接收⽅使⽤私钥进⾏解密得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通。

此时⼜带来⼀个问题，**中间⼈问题**： 如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中间⼈就可以轻松解密通信双⽅所发送的所有数据。

所以这个时候需要⼀个安全的第三⽅颁发证书（CA），证明身份的身份，防⽌被中间⼈攻击。 证书中包括：签发者、证书⽤途、使⽤者公钥、使⽤者私钥、使⽤者的HASH算法、证书到期时间等。

但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，数字签名。

申请证书时：数字签名就是⽤CA⾃带的HASH算法对证书的内容进⾏HASH得到⼀个摘要，再⽤CA的私钥加密，最终组成数字签名。
使用证书时：当别⼈把他的证书发过来的时候，我再⽤同样的Hash算法,再次⽣成消息摘要；然后⽤CA的公钥对数字签名解密，得到CA创建的消息摘要，两者⼀⽐,就知道中间有没有被⼈篡改了。这个时候就能最⼤程度保证通信的安全了。

也就是：

服务端申请证书时：数字签名 = CA私钥(加密) * [ 消息摘要Hash值 = ( 服务端证书 * HASH算法  ) ]
客户端验证证书时：[ 消息摘要Hash值 = ( 待检验证书 * HASH算法  ) ] ?== [ 消息摘要Hash值 = (  CA公钥(解密) * 待验证数字签名 ) ]






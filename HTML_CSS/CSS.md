# CSS

## CSS3新特性
- 选择器 :not(xxx)
- 圆角 border-radius
- 多列布局 multi-column layout
- 阴影和反射 Shadoweflect
- 文字特效 text-shadow
- 文字渲染 Text-decoration
- 线性渐变 gradient
- 2D/3D变换 transform 旋转,缩放,定位,倾斜,动画,多背景



## 盒模型

包括：外边距（margin）、边框（border）、内边距（padding）、实际内容（content）四个属性

W3C盒子模型(标准盒模型)：盒子总宽度/高度 =width/height + padding + border + margin
IE盒子模型：盒子总宽度/高度 =width/height + margin = (内容区宽度/高度 + padding + border) + margin。

标准：box-sizing: content-box;( 浏览器默认设置 )
IE：box-sizing: border-box;

获取盒模型对应的宽和高：
- dom.style.width/height只能取到行内样式的宽和高，style 标签中和 link 外链的样式取不到。
- dom.currentStyle.width/height（只有IE兼容）取到的是最终渲染后的宽和高
- window.getComputedStyle(dom).width/height同（2）但是多浏览器支持，IE9 以上支持。
- dom.getBoundingClientRect().width/height也是得到渲染后的宽和高，大多浏览器支持。IE9 以上支持，除此外还可以取到相对于视窗的上下左右的距离。
- dom.offsetWidth/offsetHeight包括高度（宽度）、内边距和边框，不包括外边距。最常用，兼容性最好。



## 布局元素分类

- 内联元素 inline：设置宽高无效，可以设置水平方向的margin和padding属性，不能设置垂直方向，不会自动换行，html4不能嵌套块级元素（span、a、b、img、input、select、strong、i、em、br、textarea）
- 块级元素 block：可以设置宽高，默认自高父宽，独占一行（div、h1-6、hr、p、form、table、ul、li、dl、dd）
- 内联块级元素 inline-block：可设置宽高，不换行



## css预处理 / 后处理器

- 预处理：Sass、Scss、Less、Stylus，便于开发

- 后处理器：postCss，添加浏览器私有前缀，实现跨浏览器兼容性的问题，px转rem等



## CSS选择器及其优先级

| **选择器**     | **格式**      | **优先级权重** |
| -------------- | ------------- | -------------- |
| id选择器       | #id           | 100            |
| 类选择器       | #classname    | 10             |
| 属性选择器     | a[ref=“eee”]  | 10             |
| 伪类选择器     | li:last-child | 10             |
| 标签选择器     | div           | 1              |
| 伪元素选择器   | li:after      | 1              |
| 相邻兄弟选择器 | h1+p          | 0              |
| 子选择器       | ul>li         | 0              |
| 后代选择器     | li a          | 0              |
| 通配符选择器   | *             | 0              |

- !important声明的样式的优先级最高；
- 样式表的来源不同时，优先级顺序为：内联样式 > 内部样式 > 外部样式 > 浏览器用户自定义样式 > 浏览器默认样式。



## display的属性值及其作用

| **属性值**   | **作用**                                                   |
| ------------ | ---------------------------------------------------------- |
| none         | 元素不显示，并且会从文档流中移除。                         |
| block        | 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。       |
| inline       | 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。 |
| inline-block | 默认宽度为内容宽度，可以设置宽高，同行显示。               |
| list-item    | 像块类型元素一样显示，并添加样式列表标记。                 |
| table        | 此元素会作为块级表格来显示。                               |
| inherit      | 规定应该从父元素继承display属性的值。                      |



## 隐藏元素的方法

- **display: none**：让元素完全从渲染树中消失，渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。
- **visibility: hidden**：继承属性，不会让元素从渲染树中消失，元素在页面中仍占据空间，但是不会响应绑定的监听事件。
- **opacity: 0**：不会让元素从渲染树中消失，将元素的透明度设置为 0。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。
- **position: absolute**：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。
- **z-index: 负值**：来使其他元素遮盖住该元素，以此来实现隐藏。
- **clip/clip-path** ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。
- **transform: scale(0,0)**：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。



## link和@import的区别

两者都是外部引用CSS的方式

|                   | link                                              | @import              |
| ----------------- | ------------------------------------------------- | -------------------- |
| 范畴              | XHTML标签，除了加载CSS外，还可以定义RSS等其他事务 | CSS，只能加载CSS     |
| 加载时机          | 页面载入时同时加载                                | 网页完全载入以后加载 |
| 兼容性            | 无兼容问题                                        | CSS2.1+              |
| 能否使用JS控制DOM | 支持                                              | 不支持               |



## Transition和Animation的区别

- **transition**：过度属性，强调过度，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。
- **animation**：动画属性，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。



## **伪元素和伪类的区别和作用**

- 伪类：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们。
- 伪元素：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。



## RequestAnimationframe 请求动画帧

告诉浏览器你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，回调函数会传入DOMHighResTimeStamp参数，该回调函数会在浏览器下一次重绘之前执行。属于**宏任务**。

- 语法：window.requestAnimationFrame(callback)
- 取消动画：cancelAnimationFrame(callback)

优势：
- CPU节能：使用SetTinterval 实现的动画，当页面被隐藏或最小化时仍然在后台执行动画任务，RequestAnimationframe 不会
- 函数节流：可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销，60HZ每16.7ms刷新一次
- 减少DOM操作：把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成



## 为什么有时候⽤Translate来改变位置⽽不是定位

translate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。 ⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。



## li 与 li 之间（display:inline-block元素）有看不见的空白间隔是什么原因引起的？如何解决？

li标签之间有换行符或空格

解决办法：为 li 设置float:left 、 将所有`<li>`写在同一行、 为 li 设置 font-size:0、消除`<ul>`的字符间隔letter-spacing:-8px



## 替换元素

典型的可替换元素有：iframe、video、img、embed

所有的替换元素都是**内联水平元素**（inline或inline-block），**展现效果不是由 CSS 来控制的**，这些元素是一种外部对象，它们外观的渲染，是独立于 CSS 的。它们的内容不受当前文档的样式的影响。CSS 可以影响可替换元素的位置，但不会影响到可替换元素自身的内容。某些可替换元素，例如iframe元素，可能**具有自己的样式表、尺寸**，但它们不会继承父文档的样式。

- **固有尺寸：** 指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。
- **HTML尺寸：** 只能通过HTML原生属性改变，这些HTML原生属性包括的width和height属性、的size属性。
- **CSS尺寸：** 特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的尺寸，对应盒尺寸中的content box。

这三层结构的计算规则具体如下：

- 如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。
- 如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。
- 如果有CSS尺寸，则最终尺寸由CSS属性决定。
- 如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。
- 如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。
- 内联替换元素和块级替换元素使用上面同一套尺寸计算规则。



## 常见的图片格式及使用场景

- **BMP**，是**无损**的、既支持**索引色**也支持**直接色**的**点阵图**。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是**较大**的文件。
- **GIF**，是**无损**的、采用**索引色**的**点阵图**。采用LZW压缩算法进行编码。**文件小**，是GIF格式的优点，同时，GIF格式还具有支持**动画**以及**透明**的优点。但是GIF格式仅支持**8bit**的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。
- **PNG-8**是**无损**的、使用**索引色**的**点阵图**。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有**更小**的文件体积。除此之外，PNG-8还支持**透明度**的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。
- **PNG-24**是**无损**的、使用**直接色**的**点阵图**。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8**大得多**。
- **JPEG**，是**有损**的、采用**直接色**的**点阵图**。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来**存储照片**，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF**更大**。
- **SVG**是**无损**的**矢量图**。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制**Logo、Icon**等。
- **WebP**是谷歌开发的一种新图片格式，WebP是同时支持**有损和无损**压缩的、使用**直接色**的**点阵图**。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。
	- 在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；
	- 在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；
	- WebP图片格式支持图片**透明度**，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。

|        | 类型   | 压缩      | 颜色          | 透明度 | 大小 | 用途特点       |
| ------ | ------ | --------- | ------------- | ------ | ---- | -------------- |
| BMP    | 点阵图 | 无        | 索引色/直接色 | 不支持 | 大   | 原图           |
| GIF    | 点阵图 | 无损      | 8bit索引色    | 支持   | 较小 | 透明动画       |
| PNG-8  | 点阵图 | 无损      | 索引色        | 支持   | 更小 | 低质量透明图   |
| PNG-24 | 点阵图 | 无损      | 直接色        | 支持   | 较大 | 高质量透明图   |
| JPEG   | 点阵图 | 有损      | 直接色        | 不支持 | 中   | 存储照片、大图 |
| WebP   | 点阵图 | 无损/有损 |               | 支持   | 很小 | 网页最佳       |
| SVG    | 矢量图 | 无损      | 直接色        | 支持   | 很小 | logo、图标     |



## Canvas和SVG的区别

**（1）SVG：** SVG可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言XML描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。其特点如下：

- 不依赖分辨率
- 支持事件处理器
- 最适合带有大型渲染区域的应用程序（比如谷歌地图）
- 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）
- 不适合游戏应用

**（2）Canvas：** Canvas是画布，通过Javascript来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。其特点如下：

- 依赖分辨率
- 不支持事件处理器
- 弱的文本渲染能力
- 能够以 .png 或 .jpg 格式保存结果图像
- 最适合图像密集型的游戏，其中的许多对象会被频繁重绘



## 精灵图 CSSSprites

将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。

CSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。

**优点：**

- 利用`CSS Sprites`能很好地减少网页的http请求，从而大大提高了页面的性能，这是`CSS Sprites`最大的优点；
- `CSS Sprites`能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。

**缺点：**

- 在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；
- `CSSSprites`在开发的时候相对来说有点麻烦，需要借助`photoshop`或其他工具来对每个背景单元测量其准确的位置。
- 维护方面：`CSS Sprites`在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的`CSS`，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动`CSS`。



## ::before 和 :after 的双冒号和单冒号有什么区别？

- 冒号(`:`)用于`CSS3`伪类，双冒号(`::`)用于`CSS3`伪元素。 ::before`就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于`dom`之中，只存在在页面之中。
- **注意：** `:before `和 `:after` 这两个伪元素，是在`CSS2.1`里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着`Web`的进化，在`CSS3`的规范里，伪元素的语法被修改成使用双冒号，成为`::before`、`::after`。



## 单行、多行文本溢出隐藏

- 单行文本溢出

	```css
  overflow: hidden;            // 溢出隐藏
  text-overflow: ellipsis;      // 溢出用省略号显示
  white-space: nowrap;         // 规定段落中的文本不进行换行
	```

- 多行文本溢出

  ```css
  overflow: hidden;            // 溢出隐藏
  text-overflow: ellipsis;     // 溢出用省略号显示
  display:-webkit-box;         // 作为弹性伸缩盒子模型显示。
  -webkit-box-orient:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列
  -webkit-line-clamp:3;        // 显示的行数
  //注意：由于上面的三个属性都是 CSS3 的属性，没有浏览器可以兼容，所以要在前面加一个-webkit- 来兼容一部分浏览器。
  ```
  



## z-index属性在什么情况下会失效

通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是**relative，absolute或是fixed**。z-index属性在下列情况下会失效：

- 父元素position为**relative**时，子元素的z-index失效。解决：父元素position改为absolute或static；
- 元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；
- 元素在设置z-index的同时还设置了**float浮动**。解决：float去除，改为display：inline-block；



## CSS 工程化的理解

CSS 工程化是为了解决以下问题：

- **宏观设计**：CSS 代码如何组织、如何拆分、模块结构怎样设计？
- **编码优化**：怎样写出更好的 CSS？
- **构建**：如何处理我的 CSS，才能让它的打包结果最优？
- **可维护性**：代码写完了，如何最小化它后续的变更成本？如何确保任何一个同事都能轻松接手？

以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践：

- 预处理器：Less、 Sass 等；
- 重要的工程化插件： PostCss；
- Webpack loader 等 。

基于这三个方向，可以衍生出一些具有典型意义的子问题，这里我们逐个来看：

**（1）预处理器：为什么要用预处理器？它的出现是为了解决什么问题？**

预处理器，其实就是 CSS 世界的“轮子”。预处理器支持我们写一种类似 CSS、但实际并不是 CSS 的语言，然后把它编译成 CSS 代码： ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d58c5313e884e38b1545a5896613250~tplv-k3u1fbpfcp-watermark.awebp) 那为什么写 CSS 代码写得好好的，偏偏要转去写“类 CSS”呢？这就和本来用 JS 也可以实现所有功能，但最后却写 React 的 jsx 或者 Vue 的模板语法一样——为了爽！要想知道有了预处理器有多爽，首先要知道的是传统 CSS 有多不爽。随着前端业务复杂度的提高，前端工程中对 CSS 提出了以下的诉求：

1. 宏观设计上：我们希望能优化 CSS 文件的目录结构，对现有的 CSS 文件实现复用；
2. 编码优化上：我们希望能写出结构清晰、简明易懂的 CSS，需要它具有一目了然的嵌套层级关系，而不是无差别的一铺到底写法；我们希望它具有变量特征、计算能力、循环能力等等更强的可编程性，这样我们可以少写一些无用的代码；
3. 可维护性上：更强的可编程性意味着更优质的代码结构，实现复用意味着更简单的目录结构和更强的拓展能力，这两点如果能做到，自然会带来更强的可维护性。

这三点是传统 CSS 所做不到的，也正是预处理器所解决掉的问题。预处理器普遍会具备这样的特性：

- 嵌套代码的能力，通过嵌套来反映不同 css 属性之间的层级关系 ；
- 支持定义 css 变量；
- 提供计算函数；
- 允许对代码片段进行 extend 和 mixin；
- 支持循环语句的使用；
- 支持将 CSS 文件模块化，实现复用。

**（2）PostCss：PostCss 是如何工作的？我们在什么场景下会使用 PostCss？**

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2911f98bbacf4b1cbffbb9e1527a4977~tplv-k3u1fbpfcp-watermark.awebp) 它和预处理器的不同就在于，预处理器处理的是 类CSS，而 PostCss 处理的就是 CSS 本身。Babel 可以将高版本的 JS 代码转换为低版本的 JS 代码。PostCss 做的是类似的事情：它可以编译尚未被浏览器广泛支持的先进的 CSS 语法，还可以自动为一些需要额外兼容的语法增加前缀。更强的是，由于 PostCss 有着强大的插件机制，支持各种各样的扩展，极大地强化了 CSS 的能力。

PostCss 在业务中的使用场景非常多：

- 提高 CSS 代码的可读性：PostCss 其实可以做类似预处理器能做的工作；
- 当我们的 CSS 代码需要适配低版本浏览器时，PostCss 的 [Autoprefixer](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fpostcss%2Fautoprefixer) 插件可以帮助我们自动增加浏览器前缀；
- 允许我们编写面向未来的 CSS：PostCss 能够帮助我们编译 CSS next 代码；

**（3）Webpack 能处理 CSS 吗？如何实现？** Webpack 能处理 CSS 吗：

- **Webpack 在裸奔的状态下，是不能处理 CSS 的**，Webpack 本身是一个面向 JavaScript 且只能处理 JavaScript 代码的模块化打包工具；
- Webpack 在 loader 的辅助下，是可以处理 CSS 的。

如何用 Webpack 实现对 CSS 的处理：

- Webpack 中操作 CSS 需要使用的两个关键的 loader：css-loader 和 style-loader
- 注意，答出“用什么”有时候可能还不够，面试官会怀疑你是不是在背答案，所以你还需要了解每个 loader 都做了什么事情：
  - css-loader：导入 CSS 模块，对 CSS 代码进行编译处理；
  - style-loader：创建style标签，把 CSS 内容写入标签。

在实际使用中，**css-loader 的执行顺序一定要安排在 style-loader 的前面**。因为只有完成了编译过程，才可以对 css 代码进行插入；若提前插入了未编译的代码，那么 webpack 是无法理解这坨东西的，它会无情报错。



## BFC（块级格式化上下文）

BFC是CSS布局的一个概念，是一块独立的渲染区域，是一个环境，里面的元素不会影响到外部的元素 。

**创建BFC的条件：**

- 根元素：HTML；
- 浮动：float 除 none 以外的值；
- 绝对定位元素：position (absolute、fixed)；
- display 值为：inline-block、table-cell、table-caption、flex等；
- overflow 值为：hidden、auto、scroll；

**BFC的特点：**

- 垂直方向上，自上而下排列，和文档流的排列方式一致。
- 在BFC中上下相邻的两个容器的margin会重叠
- 计算BFC的高度时，需要计算浮动元素的高度
- BFC区域不会与浮动的容器发生重叠
- BFC是独立的容器，容器内部元素不会影响外部元素
- 每个元素的左margin值和容器的左border相接触

**BFC的作用：**

- **解决margin的重叠问题**：由于BFC是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个BFC，就解决了margin重叠的问题。
- **解决高度塌陷的问题**：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把父元素变成一个BFC。常用的办法是给父元素设置`overflow:hidden`。
- **创建自适应两栏布局**：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。



## IFC: 行内格式化上下文

IFC的特点：

- 内部的Box会在水平方向，从含块的顶部开始一个接着一个地放置；
- 这些Box之间的水平方向的margin，border和padding都有效；
- Box垂直对齐方式：以它们的底部、顶部对齐，或以它们里面的文本的基线（baseline）对齐（默认， 文本与图片对其），例：line-heigth与vertical-align。



## 常见的CSS布局单位

px、%、em、rem、vw/vh、



## 为什么需要清除浮动？清除浮动的方式

**浮动的定义：** 非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。

**浮动的工作原理：**

- 浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）
- 浮动元素碰到包含它的边框或者其他浮动元素的边框停留

浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。

**清除浮动的方式**：

- 给父级div定义`height`属性
- 最后一个浮动元素之后添加一个空的div标签，并添加`clear:both`样式
  - 使用 clear 属性清除浮动的原理：**元素盒子的边不能和前面的浮动元素相邻**

- 包含浮动元素的父级标签变为BFC，如添加`overflow:hidden`或者`overflow:auto`
- 使用 :after 伪元素。

```css
  .clearfix:after{
      content: "\200B";
      display: table; 
      height: 0;
      clear: both;
    }
```

  

### 什么是margin重叠问题？如何解决？

**问题描述：** 两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，**浮动的元素和绝对定位**这种脱离文档流的元素的外边距不会折叠。重叠只会出现在**垂直方向**。

**计算原则：** 折叠合并后外边距的计算原则如下：

- 如果两者都是正数，那么就去最大者
- 如果是一正一负，就会正值减去负值的绝对值
- 两个都是负值时，用0减去两个中绝对值大的那个

**解决办法：** 对于折叠的情况，主要有两种：

- 兄弟之间重叠：底部元素变为BFC

- 父子之间重叠：父元素变为BFC 或者 子元素变为BFC




## 元素的层叠顺序

层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。下面是盒模型的层叠规则： ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbc59ae1adb5454c8c7f60582df10ff9~tplv-k3u1fbpfcp-watermark.awebp) 

对于上图，由上到下分别是： 
- 背景和边框：建立当前层叠上下文元素的背景和边框。 
- 负的z-index：当前层叠上下文中，z-index属性值为负的元素。 
- 块级盒：文档流内非行内级非定位后代元素。 
- 浮动盒：非定位浮动元素。 
- 行内盒：文档流内行内级非定位后代元素。 
- z-index:0：层叠级数为0的定位元素。 
- 正z-index：z-index属性值为正的定位元素。

**注意:** 当定位元素z-index:auto，生成盒在当前层叠上下文中的层级为 0，不会建立新的层叠上下文，除非是根元素。



## position的属性有哪些，区别是什么

| 属性值   | 概述                                                         |
| -------- | ------------------------------------------------------------ |
| absolute | 生成绝对定位的元素，相对于static定位以外的一个父元素进行定位。元素的位置通过left、top、right、bottom属性进行规定。将display置为inline-block |
| relative | 生成相对定位的元素，相对于其原来的位置进行定位。元素的位置通过left、top、right、bottom属性进行规定。 |
| fixed    | 生成绝对定位的元素，指定元素相对于屏幕视⼝（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定位⽅式。将display置为inline-block |
| static   | 默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者 z-index 声明，块级元素从上往下纵向排布，⾏级元素从左向右排列。 |
| inherit  | 规定从父元素继承position属性的值                             |
| sticky   | 粘性定位，粘性定位的元素是依赖于用户的滚动，它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed; |



## display、float、position的关系

- 首先判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。
- 然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。
- 如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。
- 如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。

总的来说，可以把它看作是一个类似优先级的机制，"position:absolute"和"position:fixed"优先级最高，有它存在的时候，浮动不起作用，'display'的值也需要调整；其次，元素的'float'特性的值不是"none"的时候或者它是根元素的时候，调整'display'的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，'display'特性值同设置值。






# 优化

## 大量DOM时的优化：

- 缓存DOM节点，避免直接遍历和引用
- 用innerHtml代替高频的appendChild
- 把导致重绘的DOM放入requestAnimationFrame
- 把渲染树上的DOM拷贝出来，不在渲染树的DOM进行修改，利用文档片段Document.createDocumentFragment()修改完虚拟节点再替换上去，完成后再放回渲染树
- js模拟DOM，将dom抽象为虚拟DOM(字符串对象)，DOM操作时先操作虚拟DOM，然后用Diff算法将虚拟DOM和真实DOM做对比，最终批量修改要修改的DOM



## SEO优化

- meta标签使用title、description、keywords
- 标签细节：使用语义化标签、使用strong em标签强调、一个页面用一个h1标签、img标签使用alt、表格使用caption标题、控制首页链接数量、a标签引用外部链接要加rel='nofollow'防止跳出，href中尽量不带参数
- 网站结构布局：把重要内容通过布局放到前面，导航优化，网站扁平化，最好别超过3层，做好404页面
- 爬虫爬不到：少使用IFrame、视频、音频、flash，内容不写js脚本里面，用get请求页面不用post请求，不希望爬取的页面用robots.txt控制
- 服务器渲染：ajax请求爬虫会爬不到，使用服务器渲染直接输出内容
- 网站提交：到各个搜索引擎收录
- 友情链接：到别的网站加入我们的链接
- 优化网络安全和性能：使用https、减少请求链接、加快请求访问速度



## CSS 优化和提高性能的方法

加载性能：
- css压缩：将写好的css进行打包压缩，可以减小文件体积。
- css单一样式：当需要下边距和左边距的时候，很多时候会选择使用 margin:top 0 bottom 0；但margin-bottom:bottom;margin-left:left;执行效率会更高。
- 减少使用@import，建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。

选择器性能：
- 关键选择器：key selector，选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；
- **过滤掉无关的规则**：如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。这样样式系统就不会浪费时间去匹配它们了。
- **避免使用 * 通配规则**
- **少使用标签选择器**：而是用class
- **少使用后代选择器**：降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素
- **避免重复规则**：了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则

渲染性能：
- 慎重使用**高性能属性**：浮动、定位。
- 尽量**减少页面重排、重绘**，如使用**RequestAnimationframe** 、⽤Translate来改变位置(会创建⼀个**GPU图层**)⽽不是定位。
- 去除**空规则**：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。
- 属性值为**0**时，不加单位。
- 属性值为**浮动小数**0.**，可以省略小数点之前的0。
- 标准化各种浏览器**前缀**：带浏览器前缀的在前。标准属性在后。
- 选择器优化**嵌套**，尽量避免层级过深。
- css**雪碧图**，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。
- 正确使用**display**的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。
- 不滥用web**字体**。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。

可维护性、健壮性：
- 将具有相同属性的样式**抽离**出来，整合并通过class在页面中进行使用，提高css的可维护性。
- 样式与内容**分离**：将css代码定义到外部css中。

